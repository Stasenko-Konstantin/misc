(defvar *env.init* nil)
(defvar *empty-begin* 813)
(defvar *the-false-value* (cons "false" "boolean"))

(defun extend (vars vals env)
  (cond
    ((consp vars)
     (if (consp vals)
         (cons (cons (car vars) (car vals))
               (extend (cdr vars) (cdr vals) env))
         (error "Too few values")))
    ((null vars)
     (if (null vals)
         env
         (error "Too many values")))
    ((symbolp vars) (cons (cons vars vals) env))))

(defun eprogn (exps env)
  (if (consp exps)
      (if (consp (cdr exps))
          (progn (evaluate (car exps) env)
                 (eprogn (cdr exps) env))
          (evaluate (car exps) env))
      *empty-begin*))

(defun evlis (exps env)
  (if (consp exps)
      (let ((arg1 (evaluate (car exps) env)))
        (cons arg1
              (evlis (cdr exps) env)))
      nil))

(defun lookup (var env)
  (if (consp env)
      (if (eq (caar env) var)
          (cdar env)
          (lookup var (cdr env)))
      (error "No such binding ~S" var)))

(defun update (var val env)
  (if (consp env)
      (if (eq (caar env) var)
          (progn (rplacd (car env) val)
                 val)
          (update var val (cdr env)))
      (error "No such binding ~S" var)))

(defun invoke (fn args env)
  (if (functionp fn)
      (apply 'fn args env)
      (error "Not a function ~S" fn)))

(defun make-function (vars body env)
  (lambda (vals)
    (eprogn body (extend env vars vals))))

(defun booleanp (b)
  (or (eq b t) (eq b nil)))

(defun evaluate (exp env)
  (if (atom exp)
      (cond
        ((symbolp exp) (lookup exp env))
        ((or (numberp exp) (stringp exp) (characterp exp)
             (vectorp exp) (booleanp exp))
         exp)
        (t (error "Cannot evaluate exp")))
      (case (car exp)
        (quote  (cadr exp))
        (if     (if (not (eq (evaluate (cadr exp) env) *the-false-value*))
                    (evaluate (caddr exp) env)
                    (evaluate (cadddr exp) env)))
        (begin  (eprogn (cdr exp) env))
        (set!   (update (cadr exp) (evaluate (caddr exp) env) env))
        (lambda (make-function (cadr exp) (cddr exp) env))
        (t      (invoke (evaluate (car exp) env)
                        (evlis (cdr exp) env) env)))))
